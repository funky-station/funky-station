// SPDX-FileCopyrightText: 2022 Flipp Syder <76629141+vulppine@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 DEATHB4DEFEAT <77995199+DEATHB4DEFEAT@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Morb <14136326+Morb0@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 csqrb <56765288+CaptainSqrBeard@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Tay <td12233a@gmail.com>
// SPDX-FileCopyrightText: 2025 pa.pecherskij <pa.pecherskij@interfax.ru>
// SPDX-FileCopyrightText: 2025 taydeo <td12233a@gmail.com>
// SPDX-FileCopyrightText: 2026 TrixxedHeart <46364955+TrixxedBit@users.noreply.github.com>
//
// SPDX-License-Identifier: MIT

using System.Linq;
using System.Numerics;
using Content.Shared.Humanoid;
using Content.Shared.Humanoid.Markings;
using Content.Shared.Humanoid.Prototypes;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Graphics.RSI;
using Robust.Shared.IoC;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;
using static Robust.Client.UserInterface.Controls.BoxContainer;

namespace Content.Client.Humanoid;
// _Funkystation: This entire file is effectively reworked for Funky
[GenerateTypedNameReferences]
public sealed partial class MarkingPicker : Control
{
    [Dependency] private readonly MarkingManager _markingManager = default!;
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    [Dependency] private readonly IEntityManager _entityManager = default!;

    private readonly SpriteSystem _sprite;

    public Action<MarkingSet>? OnMarkingAdded;
    public Action<MarkingSet>? OnMarkingRemoved;
    public Action<MarkingSet>? OnMarkingColorChange;
    public Action<MarkingSet>? OnMarkingRankChange;

    private List<Color> _currentMarkingColors = new();

    private MarkingPrototype? _selectedMarking;
    private ItemList.Item? _selectedUnusedMarking;
    private ItemList.Item? _selectedUsedMarking;
    private MarkingCategories _selectedMarkingCategory = MarkingCategories.Chest;


    // prevent recursive selection events
    private bool _isUpdatingSelection = false;

    private MarkingSet _currentMarkings = new();

    private List<MarkingCategories> _markingCategories = Enum.GetValues<MarkingCategories>().ToList();

    private string _currentSpecies = SharedHumanoidAppearanceSystem.DefaultSpecies;
    private Sex _currentSex = Sex.Unsexed;
    public Color CurrentSkinColor = Color.White;
    public Color CurrentEyeColor = Color.Black;
    public Marking? HairMarking;
    public Marking? FacialHairMarking;

    private readonly HashSet<MarkingCategories> _ignoreCategories = new();

    public string IgnoreCategories
    {
        get => string.Join(',',  _ignoreCategories);
        set
        {
            _ignoreCategories.Clear();
            var split = value.Split(',');
            foreach (var category in split)
            {
                if (!Enum.TryParse(category, out MarkingCategories categoryParse))
                {
                    continue;
                }

                _ignoreCategories.Add(categoryParse);
            }

            SetupCategoryButtons();
        }
    }

    public bool Forced { get; set; }

    private bool _ignoreSpecies;

    public bool IgnoreSpecies
    {
        get => _ignoreSpecies;
        set
        {
            _ignoreSpecies = value;
            Populate(CMarkingSearch.Text);
        }
    }

    public void SetData(List<Marking> newMarkings, string species, Sex sex, Color skinColor, Color eyeColor)
    {
        var pointsProto = _prototypeManager
            .Index<SpeciesPrototype>(species).MarkingPoints;
        _currentMarkings = new(newMarkings, pointsProto, _markingManager);

        if (!IgnoreSpecies)
        {
            _currentMarkings.EnsureSpecies(species, skinColor, _markingManager); // should be validated server-side but it can't hurt
        }

        _currentSpecies = species;
        _currentSex = sex;
        CurrentSkinColor = skinColor;
        CurrentEyeColor = eyeColor;

        Populate(CMarkingSearch.Text);
        PopulateUsed();
    }

    public void SetData(MarkingSet set, string species, Sex sex, Color skinColor, Color eyeColor)
    {
        _currentMarkings = set;

        if (!IgnoreSpecies)
        {
            _currentMarkings.EnsureSpecies(species, skinColor, _markingManager); // should be validated server-side but it can't hurt
        }

        _currentSpecies = species;
        _currentSex = sex;
        CurrentSkinColor = skinColor;
        CurrentEyeColor = eyeColor;

        Populate(CMarkingSearch.Text);
        PopulateUsed();
    }

    public void SetSkinColor(Color color) => CurrentSkinColor = color;
    public void SetEyeColor(Color color) => CurrentEyeColor = color;

    /// <summary>
    /// Gets the appropriate sprite direction for a marking based on its category.
    /// Tail markings are shown from the back (North direction) for better visibility.
    /// </summary>
    private Texture GetMarkingSprite(MarkingPrototype marking)
    {
        var spriteSpec = marking.Sprites[0];

        // Show tail markings from the back
        if (marking.MarkingCategory == MarkingCategories.Tail && spriteSpec is SpriteSpecifier.Rsi rsi)
        {
            // Get the RSI state to check if it has directional sprites
            var rsiState = _sprite.RsiStateLike(rsi);
            if (rsiState is RSI.State state)
            {
                return state.GetFrame(RsiDirection.North, 0);
            }
        }

        // Default to Frame0 (South/Front direction) for all other markings
        return _sprite.Frame0(spriteSpec);
    }

    public MarkingPicker()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _sprite = _entityManager.System<SpriteSystem>();

        CMarkingCategoryButton.OnItemSelected +=  OnCategoryChange;

        // Left Panel: toggle markings on/off
        CMarkingsUnused.OnItemSelected += item =>
        {
            // Ignore selection events during updates
            if (_isUpdatingSelection)
                return;

            _selectedUnusedMarking = CMarkingsUnused[item.ItemIndex];
            var marking = (MarkingPrototype)_selectedUnusedMarking.Metadata!;

            // Only add if not already applied
            if (!_currentMarkings.TryGetMarking(_selectedMarkingCategory, marking.ID, out _))
            {
                ToggleMarking();
            }
        };

        CMarkingsUnused.OnItemDeselected += item =>
        {
            // Ignore selection events during updates
            if (_isUpdatingSelection)
                return;

            _selectedUnusedMarking = CMarkingsUnused[item.ItemIndex];
            var marking = (MarkingPrototype)_selectedUnusedMarking.Metadata!;

            // Only remove if currently applied
            if (_currentMarkings.TryGetMarking(_selectedMarkingCategory, marking.ID, out _))
            {
                ToggleMarking();
            }
        };

        // Right panel: select for color editing
        CMarkingsUsed.OnItemSelected += OnUsedMarkingSelected;

        // Right panel buttons: for changing layering
        CMarkingRankUp.OnPressed += _ => SwapMarkingUp();
        CMarkingRankDown.OnPressed += _ => SwapMarkingDown();

        CMarkingSearch.OnTextChanged += args => Populate(args.Text);
    }

    private void SetupCategoryButtons()
    {
        CMarkingCategoryButton.Clear();

        var validCategories = new List<MarkingCategories>();
        for (var i = 0; i < _markingCategories.Count; i++)
        {
            var category = _markingCategories[i];
            var markings = GetMarkings(category);
            if (_ignoreCategories.Contains(category) ||
                markings.Count == 0)
            {
                continue;
            }

            validCategories.Add(category);
            CMarkingCategoryButton.AddItem(Loc.GetString($"markings-category-{category.ToString()}"), i);
        }

        if (validCategories.Contains(_selectedMarkingCategory))
        {
            CMarkingCategoryButton.SelectId(_markingCategories.IndexOf(_selectedMarkingCategory));
        }
        else if (validCategories.Count > 0)
        {
            _selectedMarkingCategory = validCategories[0];
        }
        else
        {
            _selectedMarkingCategory = MarkingCategories.Chest;
        }
    }

    private string GetMarkingName(MarkingPrototype marking) => Loc.GetString($"marking-{marking.ID}");

    private List<string> GetMarkingStateNames(MarkingPrototype marking)
    {
        List<string> result = new();
        foreach (var markingState in marking.Sprites)
        {
            switch (markingState)
            {
                case SpriteSpecifier.Rsi rsi:
                    result.Add(Loc.GetString($"marking-{marking.ID}-{rsi.RsiState}"));
                    break;
                case SpriteSpecifier.Texture texture:
                    result.Add(Loc.GetString($"marking-{marking.ID}-{texture.TexturePath.Filename}"));
                    break;
            }
        }

        return result;
    }

    private IReadOnlyDictionary<string, MarkingPrototype> GetMarkings(MarkingCategories category)
    {
        return IgnoreSpecies
            ? _markingManager.MarkingsByCategoryAndSex(category, _currentSex)
            : _markingManager.MarkingsByCategoryAndSpeciesAndSex(category, _currentSpecies, _currentSex);
    }

    public void Populate(string filter)
    {
        SetupCategoryButtons();

        var sortedMarkings = GetMarkings(_selectedMarkingCategory).Values.Where(m =>
            m.ID.ToLower().Contains(filter.ToLower()) ||
            GetMarkingName(m).ToLower().Contains(filter.ToLower())
        ).OrderBy(p => Loc.GetString(GetMarkingName(p))).ToList();

        // Check if we're out of points
        var pointsLeft = _currentMarkings.PointsLeft(_selectedMarkingCategory);
        var outOfPoints = pointsLeft == 0 && !Forced;

        // Check if we need to rebuild markings list
        var needsRebuild = CMarkingsUnused.Count != sortedMarkings.Count;
        if (!needsRebuild)
        {
            for (var i = 0; i < CMarkingsUnused.Count; i++)
            {
                var item = CMarkingsUnused[i];
                var marking = (MarkingPrototype)item.Metadata!;
                if (marking != sortedMarkings[i])
                {
                    needsRebuild = true;
                    break;
                }
            }
        }

        if (needsRebuild)
        {
            // if needs rebuild rebuild it
            CMarkingsUnused.Clear();
            _selectedUnusedMarking = null;

            foreach (var marking in sortedMarkings)
            {
                var item = CMarkingsUnused.AddItem(GetMarkingName(marking), GetMarkingSprite(marking));
                item.Metadata = marking;
                item.Selectable = true;
                item.IconScale = 2.0f;
            }
        }

        _isUpdatingSelection = true;
        try
        {
            // If this category only has 1 point (such as tails usually) allow the user to swap between without having to deselect the last one
            var currentMarkingsCount = _currentMarkings.Markings.TryGetValue(_selectedMarkingCategory, out var existingList)
                ? existingList.Count
                : 0;
            var maxPoints = pointsLeft + currentMarkingsCount;
            var is1PointCategory = maxPoints == 1 && currentMarkingsCount == 1;

            for (var i = 0; i < CMarkingsUnused.Count; i++)
            {
                var item = CMarkingsUnused[i];
                var marking = (MarkingPrototype)item.Metadata!;
                var isApplied = _currentMarkings.TryGetMarking(_selectedMarkingCategory, marking.ID, out var appliedMarking);

                // Update selection state
                item.Selected = isApplied;

                // Update icon color
                if (isApplied && appliedMarking != null)
                {
                    item.IconModulate = appliedMarking.MarkingColors[0];
                }
                else if (outOfPoints && !is1PointCategory)
                {
                    // Grey out if out of points, UNLESS it's a category with one point
                    item.Disabled = true;
                    item.IconModulate = new Color(0.5f, 0.5f, 0.5f);
                }
                else
                {
                    // Normal state
                    item.Disabled = false;
                    item.IconModulate = Color.White;
                }
            }
        }
        finally
        {
            _isUpdatingSelection = false;
        }

        CMarkingPoints.Visible = _currentMarkings.PointsLeft(_selectedMarkingCategory) != -1;
    }

    // Populate the used marking list
    public void PopulateUsed()
    {
        var previouslySelectedMarking = _selectedMarking;

        CMarkingsUsed.Clear();

        if (!IgnoreSpecies)
        {
            _currentMarkings.EnsureSpecies(_currentSpecies, null, _markingManager);
        }

        foreach (var marking in _currentMarkings.GetReverseEnumerator(_selectedMarkingCategory))
        {
            if (!_markingManager.TryGetMarking(marking, out var markingProto))
            {
                continue;
            }

            var text = Loc.GetString(marking.Forced ? "marking-used-forced" : "marking-used",
                ("marking-name", $"{GetMarkingName(markingProto)}"),
                ("marking-category", Loc.GetString($"markings-category-{markingProto.MarkingCategory}")));

            var item = CMarkingsUsed.AddItem(text, GetMarkingSprite(markingProto), true, markingProto);
            item.IconModulate = marking.MarkingColors[0];
            item.IconScale = 2.0f;

            // Reselect the previously selected marking
            if (previouslySelectedMarking != null && markingProto.ID == previouslySelectedMarking.ID)
            {
                item.Selected = true;
                _selectedUsedMarking = item;
            }
        }

        UpdatePoints();
    }

    private void OnUsedMarkingSelected(ItemList.ItemListSelectedEventArgs args)
    {
        _selectedUsedMarking = CMarkingsUsed[args.ItemIndex];
        var markingProto = (MarkingPrototype)_selectedUsedMarking.Metadata!;
        _selectedMarking = markingProto;

        if (markingProto.ForcedColoring)
        {
            CMarkingColors.DisposeAllChildren();
            CMarkingColors.AddChild(new Label { Text = Loc.GetString("marking-forced-colors") });
            CMarkingColorPanel.Visible = true;
            return;
        }

        var stateNames = GetMarkingStateNames(markingProto);
        _currentMarkingColors.Clear();
        CMarkingColors.DisposeAllChildren();

        for (int i = 0; i < markingProto.Sprites.Count; i++)
        {
            var colorContainer = new BoxContainer
            {
                Orientation = LayoutOrientation.Vertical,
                SeparationOverride = 4
            };

            CMarkingColors.AddChild(colorContainer);

            var colorSelector = new ColorSelectorSliders
            {
                SelectorType = ColorSelectorSliders.ColorSelectorType.Hsv // Default to HSV
            };

            colorContainer.AddChild(new Label { Text = $"{stateNames[i]}:", StyleClasses = { "LabelSubText" } });
            colorContainer.AddChild(colorSelector);

            var listing = _currentMarkings.Markings[_selectedMarkingCategory];
            var color = listing[listing.Count - 1 - args.ItemIndex].MarkingColors[i];
            var currentColor = new Color(color.RByte, color.GByte, color.BByte);

            colorSelector.Color = currentColor;
            _currentMarkingColors.Add(currentColor);
            var colorIndex = _currentMarkingColors.Count - 1;

            colorSelector.OnColorChanged += _ =>
            {
                _currentMarkingColors[colorIndex] = colorSelector.Color;
                ColorChanged(colorIndex);
            };
        }

        CMarkingColorPanel.Visible = true;
    }

    private void SwapMarkingUp()
    {
        if (_selectedUsedMarking == null)
            return;

        var index = CMarkingsUsed.IndexOf(_selectedUsedMarking);
        if (ShiftMarkingRank(index, -1))
        {
            PopulateUsed();
            OnMarkingRankChange?.Invoke(_currentMarkings);
        }
    }

    private void SwapMarkingDown()
    {
        if (_selectedUsedMarking == null)
            return;

        var index = CMarkingsUsed.IndexOf(_selectedUsedMarking);
        if (ShiftMarkingRank(index, 1))
        {
            PopulateUsed();
            OnMarkingRankChange?.Invoke(_currentMarkings);
        }
    }

    private bool ShiftMarkingRank(int src, int places)
    {
        var totalCount = _currentMarkings.Markings[_selectedMarkingCategory].Count;
        if (src + places >= totalCount || src + places < 0)
        {
            return false;
        }

        switch (places)
        {
            // i.e., we're going down in rank
            case < 0:
                _currentMarkings.ShiftRankDownFromEnd(_selectedMarkingCategory, src);
                break;
            // i.e., we're going up in rank
            case > 0:
                _currentMarkings.ShiftRankUpFromEnd(_selectedMarkingCategory, src);
                break;
        }

        return true;
    }



    // repopulate in case markings are restricted,
    // and also filter out any markings that are now invalid
    // attempt to preserve any existing markings as well:
    // it would be frustrating to otherwise have all markings
    // cleared, imo
    public void SetSpecies(string species)
    {
        _currentSpecies = species;
        var markingList = _currentMarkings.GetForwardEnumerator().ToList();

        var speciesPrototype = _prototypeManager.Index<SpeciesPrototype>(species);

        _currentMarkings = new(markingList, speciesPrototype.MarkingPoints, _markingManager, _prototypeManager);
        _currentMarkings.EnsureSpecies(species, null, _markingManager);
        _currentMarkings.EnsureSexes(_currentSex, _markingManager);

        Populate(CMarkingSearch.Text);
        PopulateUsed();
    }

    public void SetSex(Sex sex)
    {
        _currentSex = sex;
        var markingList = _currentMarkings.GetForwardEnumerator().ToList();

        var speciesPrototype = _prototypeManager.Index<SpeciesPrototype>(_currentSpecies);

        _currentMarkings = new(markingList, speciesPrototype.MarkingPoints, _markingManager, _prototypeManager);
        _currentMarkings.EnsureSpecies(_currentSpecies, null, _markingManager);
        _currentMarkings.EnsureSexes(_currentSex, _markingManager);

        Populate(CMarkingSearch.Text);
        PopulateUsed();
    }

    private void UpdatePoints()
    {
        var pointsLeft = _currentMarkings.PointsLeft(_selectedMarkingCategory);
        if (pointsLeft > -1)
        {
            // Calculate current markings used and max available
            var currentMarkingsCount = _currentMarkings.Markings.TryGetValue(_selectedMarkingCategory, out var existingList)
                ? existingList.Count
                : 0;
            var maxPoints = pointsLeft + currentMarkingsCount;

            CMarkingPoints.Text = Loc.GetString("marking-points-remaining", ("current", currentMarkingsCount), ("max", maxPoints));
            // Grey when points available, red when maxed out
            CMarkingPoints.FontColorOverride = pointsLeft == 0 ? Color.FromHex("#FF4040") : Color.Gray;
            CMarkingPoints.Visible = true;
        }
        else
        {
            CMarkingPoints.Visible = false;
        }
    }

    private void OnCategoryChange(OptionButton.ItemSelectedEventArgs category)
    {
        CMarkingCategoryButton.SelectId(category.Id);
        _selectedMarkingCategory = _markingCategories[category.Id];
        Populate(CMarkingSearch.Text);
        PopulateUsed();
        UpdatePoints();
    }


    private void ColorChanged(int colorIndex)
    {
        if (_selectedMarking is null) return;

        int markingIndex = _currentMarkings.FindIndexOf(_selectedMarkingCategory, _selectedMarking.ID);

        if (markingIndex < 0) return;

        var marking = new Marking(_currentMarkings.Markings[_selectedMarkingCategory][markingIndex]);
        marking.SetColor(colorIndex, _currentMarkingColors[colorIndex]);
        _currentMarkings.Replace(_selectedMarkingCategory, markingIndex, marking);

        // Update the icon color in the right list
        if (_selectedUsedMarking != null)
        {
            _selectedUsedMarking.IconModulate = _currentMarkingColors[0];
        }

        // ALso update left list highlighting
        Populate(CMarkingSearch.Text);

        OnMarkingColorChange?.Invoke(_currentMarkings);
    }

    private void ToggleMarking()
    {
        if (_selectedUnusedMarking is null) return;

        var marking = (MarkingPrototype) _selectedUnusedMarking.Metadata!;

        // Check if marking is already applied
        if (_currentMarkings.TryGetMarking(_selectedMarkingCategory, marking.ID, out _))
        {
            // Remove it, find, and remove by ID
            _currentMarkings.Remove(_selectedMarkingCategory, marking.ID);

            UpdatePoints();

            // Clear selection and reset color panel to default state
            _selectedMarking = null;
            _selectedUsedMarking = null;
            CMarkingColors.DisposeAllChildren();
            CMarkingColors.AddChild(new Label { Text = Loc.GetString("marking-select-to-customize"), StyleClasses = { "LabelSubText" } });

            // Refresh both lists to show updated state
            Populate(CMarkingSearch.Text);
            PopulateUsed();

            OnMarkingRemoved?.Invoke(_currentMarkings);
        }
        else
        {
            // Check if we have points left to add new markings
            var pointsLeft = _currentMarkings.PointsLeft(_selectedMarkingCategory);

            if (pointsLeft == 0 && !Forced)
            {
                // Out of points, check if this is a 1 point category for swapping
                // Calculate max points = points left + current markings count
                var currentMarkingsCount = _currentMarkings.Markings.TryGetValue(_selectedMarkingCategory, out var existingList)
                    ? existingList.Count
                    : 0;
                var maxPoints = pointsLeft + currentMarkingsCount;

                if (maxPoints == 1 && currentMarkingsCount == 1)
                {
                    // This is a 1-point category with 1 marking (typically tails)
                    // Remove the existing marking and add the new one (swap)
                    var existingMarking = existingList![0];
                    _currentMarkings.Remove(_selectedMarkingCategory, existingMarking.MarkingId);

                    // Now add the new one
                    MarkingAdd();

                    // Autoselect the newly added marking in the right panel to show its colors instead of the last marking
                    if (CMarkingsUsed.Count > 0)
                    {
                        // Select the only item in the list
                        CMarkingsUsed[0].Selected = true;

                        // Manually trigger the color panel update
                        OnUsedMarkingSelected(new ItemList.ItemListSelectedEventArgs(0, CMarkingsUsed));
                    }

                    return;
                }

                // can't add, out of points
                return;
            }

            MarkingAdd();
        }
    }

    private void MarkingAdd()
    {
        if (_selectedUnusedMarking is null) return;

        if (_currentMarkings.PointsLeft(_selectedMarkingCategory) == 0 && !Forced)
        {
            return;
        }

        var marking = (MarkingPrototype) _selectedUnusedMarking.Metadata!;
        var markingObject = marking.AsMarking();

        // We need add hair markings in cloned set manually because _currentMarkings doesn't have it
        var markingSet = new MarkingSet(_currentMarkings);
        if (HairMarking != null)
        {
            markingSet.AddBack(MarkingCategories.Hair, HairMarking);
        }
        if (FacialHairMarking != null)
        {
            markingSet.AddBack(MarkingCategories.FacialHair, FacialHairMarking);
        }

        if (!_markingManager.MustMatchSkin(_currentSpecies, marking.BodyPart, out var _, _prototypeManager))
        {
            // Do default coloring
            var colors = MarkingColoring.GetMarkingLayerColors(
                marking,
                CurrentSkinColor,
                CurrentEyeColor,
                markingSet
            );
            for (var i = 0; i < colors.Count; i++)
            {
                markingObject.SetColor(i, colors[i]);
            }
        }
        else
        {
            // Color everything in skin color
            for (var i = 0; i < marking.Sprites.Count; i++)
            {
                markingObject.SetColor(i, CurrentSkinColor);
            }
        }

        markingObject.Forced = Forced;

        _currentMarkings.AddBack(_selectedMarkingCategory, markingObject);

        UpdatePoints();
        _selectedUnusedMarking = null;

        // Refresh both lists to show updated state
        Populate(CMarkingSearch.Text);
        PopulateUsed();

        OnMarkingAdded?.Invoke(_currentMarkings);
    }
}
