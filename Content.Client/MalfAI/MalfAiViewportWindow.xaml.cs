// SPDX-FileCopyrightText: 2025 Tyranex <bobthezombie4@gmail.com>
//
// SPDX-License-Identifier: MIT

using System.Numerics;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Map;
using Robust.Shared.GameObjects;

namespace Content.Client.MalfAI;

[GenerateTypedNameReferences]
public sealed partial class MalfAiViewportWindow : DefaultWindow
{
    // Configurable zoom factor (1 = default world scale, <1 zooms in, >1 zooms out)
    private const float DefaultZoom = 0.5f;

    private FixedEye? _eye;
    private readonly NetEntity? _anchorEntity;

    public MalfAiViewportWindow(MapId mapId, Vector2 worldPos, Vector2i sizePixels, string title, float rotation = 0f, int zoomLevel = 5, NetEntity? anchorEntity = null)
    {
        RobustXamlLoader.Load(this);
        _anchorEntity = anchorEntity;
        Title = title;

        // Enforce a square internal viewport to guarantee 1:1 aspect ratio regardless of window size.
        var square = sizePixels.X > 0 && sizePixels.Y > 0 ? Math.Min(sizePixels.X, sizePixels.Y) : 400;
        var squareSize = new Vector2i(square, square);

        // Apply size hints to keep the window roughly to the requested size but ensure square viewport.
        MinWidth = square;
        MinHeight = square;
        Viewport.ViewportSize = squareSize;

        // Use anchor entity if available, otherwise fall back to static eye
        if (_anchorEntity != null)
        {
            var entityManager = IoCManager.Resolve<IEntityManager>();
            var anchorEntityUid = entityManager.GetEntity(_anchorEntity.Value);

            if (entityManager.EntityExists(anchorEntityUid) && entityManager.TryGetComponent<EyeComponent>(anchorEntityUid, out var eyeComp))
            {
                // Use the anchor entity's eye which will track with the grid
                Viewport.Eye = eyeComp.Eye;
                _eye = null; // Don't create our own eye
            }
            else
            {
                // Fallback to static eye if anchor doesn't have eye component
                CreateStaticEye(mapId, worldPos, rotation);
            }
        }
        else
        {
            // No anchor entity, use static eye
            CreateStaticEye(mapId, worldPos, rotation);
        }

        // Ensure we release the eye when window closes.
        OnClose += () =>
        {
            Viewport.Eye = null;
            _eye = null;
        };

        OpenCentered();
    }

    private void CreateStaticEye(MapId mapId, Vector2 worldPos, float rotation)
    {
        // Create and configure a dedicated eye centered on the requested world position.
        _eye = new FixedEye
        {
            // Draw FOV and lighting like a normal player view.
            DrawFov = true,
            DrawLight = true,
            // Eye.Zoom is inverse of Scale; setting Vector2.One * DefaultZoom zooms in (higher value = closer).
            Zoom = new Vector2(DefaultZoom, DefaultZoom),
            // Apply station rotation to match grid's north direction (negated for camera rotation)
            Rotation = -rotation
        };

        _eye.Position = new MapCoordinates(worldPos, mapId);

        // Assign eye to the viewport for rendering.
        Viewport.Eye = _eye;
    }

    protected override Vector2 MeasureOverride(Vector2 availableSize)
    {
        var baseSize = base.MeasureOverride(availableSize);

        // Clamp aspect ratio to prevent excessively wide or tall windows
        // Maximum aspect ratio of 2:1 in either direction
        const float maxAspectRatio = 2.0f;

        var width = baseSize.X;
        var height = baseSize.Y;

        var aspectRatio = width / height;

        if (aspectRatio > maxAspectRatio)
        {
            // Too wide, adjust width to match height with max aspect ratio
            width = height * maxAspectRatio;
        }
        else if (aspectRatio < 1.0f / maxAspectRatio)
        {
            // Too tall, adjust height to match width with max aspect ratio
            height = width * maxAspectRatio;
        }

        return new Vector2(width, height);
    }
}
