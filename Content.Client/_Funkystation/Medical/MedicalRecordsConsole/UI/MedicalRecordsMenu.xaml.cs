// SPDX-FileCopyrightText: 2025 corresp0nd <46357632+corresp0nd@users.noreply.github.com>
//
// SPDX-License-Identifier: MIT

using System.Linq;
using Content.Client._CD.Records.UI;
using Content.Client.UserInterface.Controls;
using Content.Shared._Funkystation.Medical.MedicalRecords;
using Content.Shared._Funkystation.Records;
using Content.Shared.StationRecords;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

namespace Content.Client._Funkystation.Medical.MedicalRecordsConsole.UI;

[GenerateTypedNameReferences]
public sealed partial class MedicalRecordsMenu : FancyWindow
{
    #region deps/events/etc
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;

    public struct CharacterListMetadata
    {
        public uint CharacterRecordKey;
        public uint? StationRecordKey;
    }

    // i am NOT making a whole style sheet for these icons right now. sorry.
    // maybe next week style funky will be real
    private const string ArrowUp = "/Textures/_Funkystation/Interface/StyleFunky/arrow_up.png";
    private const string ArrowDown = "/Textures/_Funkystation/Interface/StyleFunky/arrow_down.png";

    public event Action<CharacterListMetadata?>? OnListingItemSelected;
    public event Action<StationRecordFilterType, string?>? OnFiltersChanged;

    private StationRecordFilterType _currentFilterType;
    private bool _isPopulating;

    /// <summary>
    /// The key to the record of the currently selected item in the listing.
    /// </summary>
    private uint? _selectedListingKey;

    #endregion
    public MedicalRecordsMenu()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        // There is no reason why we can't just steal the StationRecordFilter class.
        // If wizden adds a new kind of filtering we want to replicate it here.
        foreach (var item in Enum.GetValues<StationRecordFilterType>())
        {
            RecordFilterType.AddItem(GetTypeFilterLocals(item), (int)item);
        }

        #region buttons

        CharacterListing.OnItemSelected += _ =>
        {
            if (!CharacterListing.GetSelected().Any())
                return;
            var selected = CharacterListing.GetSelected().First();
            var meta = (CharacterListMetadata)selected.Metadata!;
            _selectedListingKey = meta.CharacterRecordKey;
            if (!_isPopulating)
                OnListingItemSelected?.Invoke(meta);
        };

        CharacterListing.OnItemDeselected += _ =>
        {
            // When we populate the records, we clear the contents of the listing.
            // This could cause a deselection but we don't want to really deselect because it would
            // interrupt what the player is doing.

            if (!_isPopulating)
                OnListingItemSelected?.Invoke(null);

            _selectedListingKey = null;
        };

        // collapse buttons for each information section
        GIButton.OnButtonUp += _ =>
        {
            GeneralInformation.Visible = !GeneralInformation.Visible;
            GIButtonArrow.TexturePath = GeneralInformation.Visible ? ArrowUp : ArrowDown;
        };

        MIButton.OnButtonUp += _ =>
        {
            MedicalInformation.Visible = !MedicalInformation.Visible;
            MIButtonArrow.TexturePath = MedicalInformation.Visible ? ArrowUp : ArrowDown;
        };

        ARButton.OnButtonUp += _ =>
        {
            AutopsyInformation.Visible = !AutopsyInformation.Visible;
            ARButtonArrow.TexturePath = AutopsyInformation.Visible ? ArrowUp : ArrowDown;
        };

        // buttons to filter the crew list
        RecordFilters.OnPressed += _ =>
        {
            OnFiltersChanged?.Invoke(_currentFilterType, RecordFiltersValue.Text);
        };

        RecordFiltersReset.OnPressed += _ =>
        {
            OnFiltersChanged?.Invoke(StationRecordFilterType.Name, null);
            RecordFiltersValue.Clear();
        };

        RecordFiltersValue.OnTextEntered += text =>
        {
            OnFiltersChanged?.Invoke(_currentFilterType, text.Text);
        };

        RecordFilterType.OnItemSelected += eventArgs =>
        {
            var type = (StationRecordFilterType)eventArgs.Id;
            _currentFilterType = type;
            RecordFilterType.SelectId(eventArgs.Id);
        };

        #endregion

    }

    private bool CharacterListNeedsRepopulating(IReadOnlyDictionary<uint, MedicalRecordsConsoleState.CharacterInfo> newKeys)
    {
        var newCount = newKeys.Count;
        if (newCount != CharacterListing.Count)
            return true;

        // Given that there is the same number of keys in the dictionary as in items in the listing, they are not equal
        // if and only if there exists a key in the listing that is not in the dictionary
        return CharacterListing
            .Select(item => ((CharacterListMetadata) item.Metadata!).CharacterRecordKey)
            .Any(key => !newKeys.ContainsKey(key));
    }

    public void UpdateState(MedicalRecordsConsoleState state)
    {
        if (state.CharacterList == null)
        {
            CharacterListingStatus.Visible = true;
            CharacterListing.Visible = false;
            CharacterListingStatus.Text = "No data available";

            RecordContainer.Visible = false;
            RecordContainerStatus.Visible = true;
            return;
        }

        CharacterListingStatus.Visible = false;
        CharacterListing.Visible = true;

        if (state.Filter != null)
        {
            RecordFiltersValue.SetText(state.Filter.Value);
            RecordFilterType.SelectId((int)state.Filter.Type);
        }

        if (CharacterListNeedsRepopulating(state.CharacterList))
        {
            _isPopulating = true;

            CharacterListing.Clear();


            // Add the records to the listing in a sorted order. There is probably are faster way of doing this, but
            // this is not really a hot code path.
            state.CharacterList
                // The items in this tuple are as follows: (name of character, CharacterListMetadata)
                .Select(r
                    => (CharacterName: r.Value.CharacterDisplayName, new CharacterListMetadata() { CharacterRecordKey = r.Key, StationRecordKey = r.Value.StationRecordKey}))
                .OrderBy(r => r.Item1)
                .ToList()
                .ForEach(r => CharacterListing.AddItem(r.Item1, metadata: r.Item2));

            _isPopulating = false;
        }

        SelectRecordKey(state.SelectedIndex);

        // Enable container if we have a record selected
        if (state.SelectedRecord == null)
        {
            RecordContainerStatus.Visible = true;
            RecordContainer.Visible = false;
            return;
        }

        RecordContainerStatus.Visible = false;
        RecordContainer.Visible = true;

        var record = state.SelectedRecord!;
        PopulateInformation(record);
    }

    /* generate locale */
    // If we are using wizden's class we might as well use their localization.
    private string GetTypeFilterLocals(StationRecordFilterType type)
    {
        return Loc.GetString($"general-station-record-{type.ToString().ToLower()}-filter");
    }

    private string GetInsuranceProviderLocals(int id)
    {
        var type = (InsuranceProviders)id;
        return Loc.GetString($"character-records-insurance-provider-{type.ToString().ToLower()}");
    }

    private string GetInsuranceTypeLocals(int id)
    {
        var type = (InsuranceTypes)id;
        return Loc.GetString($"character-records-insurance-type-{type.ToString().ToLower()}");
    }

    private string GetBloodTypeLocals(int id)
    {
        var type = (BloodTypes)id;
        return Loc.GetString($"character-records-blood-{type.ToString().ToLower()}");
    }

    /// <summary>
    /// Select the record in the listing for the given key.
    /// </summary>
    /// <param name="key">The index of the record in the dictionary</param>
    private void SelectRecordKey(uint? key)
    {
        if (_selectedListingKey == key)
            return;

        _selectedListingKey = key;
        _isPopulating = true;
        CharacterListing.ClearSelected();

        // I wish there was a better way of doing this
        if (key != null)
        {
            foreach (var item in CharacterListing)
            {
                if (((CharacterListMetadata) item.Metadata!).CharacterRecordKey == key)
                {
                    item.Selected = true;
                    break;
                }
            }
        }

        _isPopulating = false;
    }

    /// <summary>
    /// i hope you have fun reading this
    /// </summary>
    /// <param name="record">character information from the database</param>
    private void PopulateInformation(FullCharacterRecords record)
    {
        // record = base wizden information
        // cr = extra flavor info added from cosmatic drift
        var cr = record.PRecords;

        // General Information
        RecordContainerName.Text = record.Name;
        RecordContainerJob.Text = record.JobTitle; /* At some point in the future we might want to display the icon */
        RecordContainerGender.Text = record.Gender.ToString();
        RecordContainerSpecies.Text = record.Species;
        RecordContainerAge.Text = record.Age.ToString();
        RecordContainerHeight.Text = cr.Height + " " + Loc.GetString("funky-medical-records-unit-cm") + " " + UnitConversion.GetImperialDisplayLength(cr.Height);
        RecordContainerWeight.Text = cr.Weight + " " + Loc.GetString("funky-medical-records-unit-kg") + " " + UnitConversion.GetImperialDisplayMass(cr.Weight);
        RecordContainerWorkAuth.Text = cr.HasWorkAuthorization ? Loc.GetString("funky-medical-records-yes") : Loc.GetString("funky-medical-records-no");
        RecordContainerInsurance.Text = cr.HasInsurance ? Loc.GetString("funky-medical-records-yes") : Loc.GetString("funky-medical-records-no");
        RecordContainerInsuranceProvider.Text = GetInsuranceProviderLocals(cr.InsuranceProvider);
        RecordContainerInsurancePlan.Text = GetInsuranceTypeLocals(cr.InsuranceType);
        InsuranceContainer.Visible = RecordContainerInsurance.Text.Equals(Loc.GetString("funky-medical-records-yes"));

        // Medical Information
        RecordContainerFingerprints.Text = record.Fingerprint ?? Loc.GetString("cd-character-records-viewer-unknown");
        RecordContainerDNA.Text = record.DNA ?? Loc.GetString("cd-character-records-viewer-unknown");
        RecordContainerBloodType.Text = GetBloodTypeLocals(cr.BloodType);
        RecordContainerIdentFeatures.Title = "[color=darkgray]" + Loc.GetString("funky-medical-records-identifying-features-title") + "[/color]";
        RecordContainerIdentFeatures.SetValue(cr.IdentifyingFeatures == "" ? "[color=white]" + Loc.GetString("cd-character-records-viewer-unknown") + "[/color]": "[color=white]" + cr.IdentifyingFeatures + "[/color]");
        RecordContainerPostMortem.Title = "[color=darkgray]" + Loc.GetString("funky-medical-records-post-mortem-title") + "[/color]";
        RecordContainerPostMortem.SetValue("[color=white]" + cr.PostmortemInstructions + "[/color]");
        RefreshMedicalInformation(cr.MedicalInfo);
    }

    /// <summary>
    /// organizes the given medical info into a hashmap, then assigns each category to
    /// its corresponding ui element
    /// </summary>
    /// <remarks>
    /// you could probably just put this in <see cref="PopulateInformation"/>,
    /// but this is a little neater
    /// </remarks>
    private void RefreshMedicalInformation(HashSet<ProtoId<MedicalInfoPrototype>> medicalInfo)
    {
        MedicalInfoContainer.DisposeAllChildren();

        var information = _prototypeManager.EnumeratePrototypes<MedicalInfoPrototype>()
            .OrderBy(t => Loc.GetString(t.Name))
            .ToList();

        Dictionary<string, List<string>> infoGroups = new();

        // this is just so it generates empty groups, rather than none at all, if a character does not have entries in that category.
        var allGroups = _prototypeManager.EnumeratePrototypes<MedicalInfoCategoryPrototype>()
            .OrderBy(t => Loc.GetString(t.Name))
            .ToList();

        foreach (var kind in allGroups) infoGroups.GetOrNew(kind.ID);

        foreach (var item in information)
        {
            // we don't need prototypes without an assigned category,
            // so just dump them instead of adding a default group
            if (item.Category == null)
                continue;

            if (!_prototypeManager.HasIndex(item.Category))
                continue;

            // if the given record doesn't have this prototype, skip it
            if (!medicalInfo.Contains(item.ID))
                continue;

            var group = infoGroups.GetOrNew(item.Category);
            group.Add(Loc.GetString(item.Name));
        }

        // build the ui
        // ill be so fr all of the stuff with setting the font colors is kinda shitcode
        // not like richtextlabels are particularly fun to use
        foreach (var (categoryId, categoryItems) in infoGroups)
        {
            if (!_prototypeManager.TryIndex<MedicalInfoCategoryPrototype>(categoryId, out var category))
                continue;

            if (category.ID == MedicalInfoCategoryPrototype.Default)
                continue;

            var item = new RecordLongItemDisplay()
            {
                Title = "[color=darkgray]" + Loc.GetString(category.Name) + ": [/color]",
                Margin = new Thickness(5),
            };

            var text = string.Join(", ", categoryItems);
            item.SetValue(text == ""
                ? "[color=white]" + Loc.GetString("funky-medical-records-viewer-none-provided") + "[/color]"
                : "[color=white]" + text + "[/color]");

            MedicalInfoContainer.AddChild(item);
        }
    }
}
