using System.Diagnostics.CodeAnalysis;
using Content.Client.UserInterface.Controls;
using Content.Shared._FarHorizons.Power.Generation.FissionGenerator;
using Content.Shared.Lock;
using Content.Shared.Rounding;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Timing;

namespace Content.Client._FarHorizons.Power.UI;

/// <summary>
/// Client-side UI used to view a nuclear reactor.
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class FissionGeneratorWindow : FancyWindow
{

    private StyleBoxFlat[,] _reactorGrid;

    private double[,] _temperatureGrid = new double[FissionGeneratorComponent.ReactorGridWidth, FissionGeneratorComponent.ReactorGridHeight];
    private int[,] _neutronGrid = new int[FissionGeneratorComponent.ReactorGridWidth, FissionGeneratorComponent.ReactorGridHeight];

    private byte displayMode = 1<<0;
    public event Action? ChangeViewButtonPressed;

    public FissionGeneratorWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        ChangeViewButton.OnPressed += _ => ChangeViewButtonPressed?.Invoke();
        ChangeViewButtonPressed += OnChangeViewButtonPressed;

        InitReactorGrid();
    }

    [MemberNotNull(nameof(_reactorGrid))]
    public void InitReactorGrid()
    {
        _reactorGrid = new StyleBoxFlat[FissionGeneratorComponent.ReactorGridWidth, FissionGeneratorComponent.ReactorGridHeight];

        for (var x = 0; x < FissionGeneratorComponent.ReactorGridWidth; x++)
        {
            for (var y = 0; y < FissionGeneratorComponent.ReactorGridHeight; y++)
            {
                var styleBox = new StyleBoxFlat();
                _reactorGrid[x,y] = styleBox;

                var control = new PanelContainer
                {
                    Margin = new Thickness(2),
                    PanelOverride = styleBox,
                    HorizontalExpand = true,
                    VerticalExpand = true,
                };
                ReactorGrid.AddChild(control);
            }
        }
    }

    public void Update(FissionGeneratorBuiState msg)
    {
        Array.Clear(_temperatureGrid);
        Array.Clear(_neutronGrid);
        for (var x = 0; x < FissionGeneratorComponent.ReactorGridWidth; x++)
        {
            for (var y = 0; y < FissionGeneratorComponent.ReactorGridHeight; y++)
            {
                _temperatureGrid[x,y] = msg.TemperatureGrid[x * FissionGeneratorComponent.ReactorGridWidth + y];
                _neutronGrid[x,y] = msg.NeutronGrid[x * FissionGeneratorComponent.ReactorGridWidth + y];
            }
        }
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        for (var x = 0; x < FissionGeneratorComponent.ReactorGridWidth; x++)
        {
            for (var y = 0; y < FissionGeneratorComponent.ReactorGridHeight; y++)
            {
                var box = _reactorGrid[x,y];
                if (displayMode % 2 == 1)
                {
                    box.BackgroundColor = GetColor(293.15, 1200, _temperatureGrid[x, y]);
                    ViewLabel.Text = "Temperature View";
                }
                else if ((displayMode >> 1) % 2 == 1)
                {
                    box.BackgroundColor = GetColor(0, 5, _neutronGrid[x, y]);
                    ViewLabel.Text = "Neutron View";
                }
            }
        }
    }

    private static Color GetColor(double pointA, double pointB, double value)
    {
        var mid = pointA+((pointB-pointA) / 2);
        Color result;

        if (value < pointA && pointA > 0)
            result = Color.InterpolateBetween(Color.DarkBlue, Color.FromHex("#31843E"), (float)(value / pointA));
        else if (value >= pointA && value < mid)
            result = Color.InterpolateBetween(Color.FromHex("#31843E"), Color.FromHex("#BBBB00"), (float)((value - pointA) / (mid - pointA)));
        else if (value >= mid && value < pointB)
            result = Color.InterpolateBetween(Color.FromHex("#BBBB00"), Color.FromHex("#BB3232"), (float)((value - mid) / (pointB - mid)));
        else if (value >= pointB)
            result = Color.FromHex("#BB3232");
        else
            result = Color.Black;

        return result;
    }

    private void OnChangeViewButtonPressed()
    {
        // The bits go marching one by one...
        displayMode <<= 1;
        if (displayMode >= 1 << 2)
            displayMode = 1 << 0;
    }
}