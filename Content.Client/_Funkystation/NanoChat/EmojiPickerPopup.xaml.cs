// SPDX-FileCopyrightText: 2025 EvaisaDev <mail@evaisa.dev>
//
// SPDX-License-Identifier: AGPL-3.0-or-later AND MIT

using System.Linq;
using Content.Shared._Funkystation.NanoChat;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.ResourceManagement;
using System.Numerics;
using Content.Client.Resources;

namespace Content.Client._Funkystation.NanoChat;

[GenerateTypedNameReferences]
public sealed partial class EmojiPickerPopup : DefaultWindow
{
    private List<(string name, string texturePath)> _filteredEmojis;

    public event Action<string>? OnEmojiSelected;

    public EmojiPickerPopup()
    {
        RobustXamlLoader.Load(this);

        _filteredEmojis = NanoChatEmojis.EmojiPaths.Select(kv => (kv.Key, kv.Value)).ToList();

        ContentsContainer.Margin = new Thickness(3);

        EmojiCloseButton.OnPressed += _ => Close();
        SearchInput.OnTextChanged += OnSearchChanged;

        OnResized += UpdateGridColumns;

        PopulateEmojiGrid();
        UpdateGridColumns();
    }

    private void UpdateGridColumns()
    {
        const int buttonSize = 48;
        const int scrollbarWidth = 12;

        var scrollContainer = EmojiGrid.Parent as ScrollContainer;
        if (scrollContainer == null)
            return;

        var availableWidth = scrollContainer.PixelSize.X - scrollbarWidth;

        if (availableWidth <= 0)
            return;

        var columns = Math.Max(1, (int) (availableWidth / buttonSize));
        if (EmojiGrid.Columns != columns)
        {
            EmojiGrid.Columns = columns;
        }
    }

    private void OnSearchChanged(LineEdit.LineEditEventArgs args)
    {
        var search = args.Text.ToLower().Trim();

        if (string.IsNullOrEmpty(search))
        {
            _filteredEmojis = NanoChatEmojis.EmojiPaths.Select(kv => (kv.Key, kv.Value)).ToList();
        }
        else
        {
            _filteredEmojis = NanoChatEmojis.EmojiPaths
                .Where(kv => kv.Key.Contains(search, StringComparison.OrdinalIgnoreCase))
                .Select(kv => (kv.Key, kv.Value))
                .ToList();
        }

        PopulateEmojiGrid();
    }

    private void PopulateEmojiGrid()
    {
        EmojiGrid.RemoveAllChildren();

        var resCache = IoCManager.Resolve<IResourceCache>();

        foreach (var (name, texturePath) in _filteredEmojis)
        {
            var button = new Button
            {
                MinSize = new Vector2(48, 48),
                MaxSize = new Vector2(48, 48),
                ToolTip = $":{name}:",
            };

            var textureRect = new TextureRect
            {
                Texture = resCache.GetTexture(texturePath),
                Stretch = TextureRect.StretchMode.KeepAspect,
                MinSize = new Vector2(32, 32),
                MaxSize = new Vector2(32, 32),
                HorizontalAlignment = HAlignment.Center,
                VerticalAlignment = VAlignment.Center,
            };

            button.AddChild(textureRect);

            button.OnPressed += _ =>
            {
                OnEmojiSelected?.Invoke($":{name}:");
                Close();
            };

            EmojiGrid.AddChild(button);
        }

        // Recalculate columns after populating
        UpdateGridColumns();
    }

    public static string GetEmojiTexture(string emojiName)
    {
        return NanoChatEmojis.EmojiPaths.TryGetValue(emojiName, out var path) ? path : string.Empty;
    }

    public static Dictionary<string, string> GetEmojis() => new Dictionary<string, string>(NanoChatEmojis.EmojiPaths);
}
